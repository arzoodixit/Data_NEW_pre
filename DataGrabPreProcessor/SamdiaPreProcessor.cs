///////////////////////////////////////////////////////////
//	Copyright (C) 2020 Bosch Automotive Service Solutions INC
//  SamdiaPreProcessor.cs
//  Implementation of the Class SamdiaPreProcessor
//  Generated by Enterprise Architect
//  Created on:      11-Jan-2021 7:41:02 PM
//  Original author: Anoopchandra PR
//	Modification History (Latest First):
//      23-Mar-2023 10:00:00 AM Anoopchandra PR Added support for CAN FD
//      21-Jul-2021 10:00:00 AM Anoopchandra PR Performance improvements and bug fixes
//      06-Apr-2021 10:00:00 AM Anoopchandra PR Updated the logic to eliminate the need for SIDs
//		18-Jan-2021 09:41:01 AM	Aravind Kumar Added Samdia Pre-processor Handling
//		11-Jan-2021 07:41:02 PM	Anoopchandra PR	Initial Version
///////////////////////////////////////////////////////////

using System;
using DataGrabomainModel;
using DataGrabDataProcessor;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Text;
using DataGrabProcessorUtility;
using System.IO;

namespace DataGrabPreProcessor
{
    public class SamdiaPreProcessor : IDataGrabPreProcessor
    {
        public SamdiaPreProcessor()
        {

        }

        ~SamdiaPreProcessor()
        {

        }

        /// <summary>
        /// Do some preparation for before pre-processing
        /// </summary>
        /// <param name="trace"></param>
        /// <returns></returns>
        private List<string> _prepareTraceForProcessing(string trace)
        {
            var output = new List<string>();
            var regex1 = new Regex("([0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9][0-9][0-9].[0-9][0-9][0-9])", RegexOptions.Compiled);
            var regex2 = new Regex("  .*        ", RegexOptions.Compiled);
            using (var stringReader = new StringReader(trace))
            {
                string rowString;
                while ((rowString = stringReader.ReadLine()) != null)
                {
                    output.Add(new StringBuilder(regex2.Replace(regex1.Replace(rowString, " "), " "))
                                    .Append(Environment.NewLine).ToString().ToUpper());
                }
                stringReader.Close();
            }
            return output;
        }

        private List<string> _getValidCanIds(List<string> inputData, out List<string> validCanIds, out List<string> ValidCanIdsWithExt)
        {
            var canAddresses = _getCanAddresses(inputData);
            var canExtAddresses = _getCanExtAddress(canAddresses);

            validCanIds = new List<string>();
            ValidCanIdsWithExt = new List<string>();

            //inputSplitted = input.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();

            //First find out valid extended addresses
            foreach (var canAddressData in canExtAddresses)
            {
                var isExtendedAddressValid = true;
                var framesToAnalyze = new List<string>();

                foreach (var ecuData in canAddressData.Value)
                {
                    if (!_isvalidDiagnosticFrames(ecuData.Value))
                    {
                        //Check whether all the messages are flow control message or not, if yes then ignore it
                        if (ecuData.Value.Where(x => x.StartsWith("30")).Count() == ecuData.Value.Count) continue;
                        isExtendedAddressValid = false;
                        break;
                    }
                    var tempBuilder = new StringBuilder();
                    tempBuilder.Append(canAddressData.Key).Append("-").Append(ecuData.Key);
                    var tempKey = tempBuilder.ToString();

                    var tempCanIdsWithExt = new List<string> { tempKey };

                    if (framesToAnalyze.Count <= 0)
                    {
                        var tempCanIds = new List<string> { canAddressData.Key };
                        framesToAnalyze = _getValidDiagnosticFramesAsList(inputData, tempCanIds);
                    }

                    var formattedFrames = _mergeCanFrames(framesToAnalyze, validCanIds, tempCanIdsWithExt);

                    if (!formattedFrames.Any(x => x.Contains(tempKey)))
                    {
                        //If all are flow control then it is a valid address
                        if (ecuData.Value.Where(x => x.StartsWith("30")).Count() != ecuData.Value.Count())
                        {
                            isExtendedAddressValid = false;
                            break;
                        }
                    }
                    if (!validCanIds.Contains(canAddressData.Key)) validCanIds.Add(canAddressData.Key);

                    if (!ValidCanIdsWithExt.Contains(tempKey))
                        ValidCanIdsWithExt.Add(tempKey);
                }
                //if extended address valid then all the extended addresses for a specific ECU address should be valid
                //If any one of the extended address is not valid then the extended addressing not valid for the entrie ECU address
                if (!isExtendedAddressValid)
                {
                    var tempBuilder = new StringBuilder();
                    tempBuilder.Append(canAddressData.Key).Append("-");
                    var tempKey = tempBuilder.ToString();
                    ValidCanIdsWithExt.RemoveAll(x => x.StartsWith(tempKey));
                }

            }
            foreach (var ecuData in canAddresses)
            {
                if (!_isvalidDiagnosticFrames(ecuData.Value)) continue;
                if (!validCanIds.Contains(ecuData.Key)) validCanIds.Add(ecuData.Key);
                var tempBuilder = new StringBuilder();
                tempBuilder.Append(ecuData.Key).Append("-");
                var tempKey = tempBuilder.ToString();
                //If a valid extended address then do not consider it as 
                if (ValidCanIdsWithExt.Where(x => x.StartsWith(tempKey)).Count() > 0) continue;
                if (!ValidCanIdsWithExt.Contains(ecuData.Key)) ValidCanIdsWithExt.Add(ecuData.Key);
            }
            return ValidCanIdsWithExt;
        }
        /// 
        /// <param name="rawDataGrab"></param>
        public ProcessedDataGrabDataModel PreProcessDataGrab(DataGrabDataModel rawDataGrab, List<string> sidList)
        {
            var currentStage = "Stage 0";
            try
            {
                var processedDataGrabDataModel = new ProcessedDataGrabDataModel();
                var TraceDataModel = new TraceDataModel();
                var TraceList = new List<TraceDataModel>();
                var trawdataSplitted = _prepareTraceForProcessing(rawDataGrab.RawData);

                if (trawdataSplitted == null || trawdataSplitted.Count <= 0) return null;
                currentStage = "Stage 0.5";
                _getValidCanIds(trawdataSplitted, out List<string> validCanIds, out List<string> ValidCanIdsWithExt);
                currentStage = "Stage 1";
                var mergedFrames = _mergeCanFrames(trawdataSplitted, validCanIds, ValidCanIdsWithExt);
                currentStage = "Stage 2";
                //Now need to find request and response address pairs
                var requestResponsePairs = _findRequestResponseAddressPairs(mergedFrames, trawdataSplitted);
                currentStage = "Stage 3";
                var tempTraceData = new List<TraceDataModel>();
                var filteredDiagnosticMessages = _removeFunctionalMessages(mergedFrames, requestResponsePairs.Keys.ToList(), out List<string> functionalMessages);
                currentStage = "Stage 4";
                //Now format the request and response based on the request and response address
                foreach (var canAddressPair in requestResponsePairs)
                {
                    var ecuAddress = canAddressPair.Key.Split('-')[0];
                    var testerAddress = canAddressPair.Value.Split('-')[0];
                    var extendedAddress = string.Empty;
                    var responseExtendedAddress = string.Empty;
                    if (canAddressPair.Value.Contains("-")) responseExtendedAddress = canAddressPair.Value.Split('-')[1];
                    if (canAddressPair.Key.Contains("-")) extendedAddress = canAddressPair.Key.Split('-')[1];

                    var filteredTrace = _filterTrace(filteredDiagnosticMessages, new List<string> { canAddressPair.Key, canAddressPair.Value });
                    var requestResponses = _getRequestResponsePairs(filteredTrace, canAddressPair.Key, canAddressPair.Value);
                    requestResponses.ToList().ForEach
                        (
                            x => x.Value.ForEach(t => tempTraceData.Add
                            (
                                new TraceDataModel
                                {
                                    EcuAddress = ecuAddress,
                                    TesterAddress = testerAddress,
                                    Request = x.Key,
                                    Response = t,
                                    EcuExtendedAddress = extendedAddress,
                                    TesterExtendedAddress = responseExtendedAddress,
                                }
                            ))
                        );
                }
                currentStage = "Stage 5";
                //Now fill the data for functional addresses
                tempTraceData.AddRange(_processFunctionalMessages(functionalMessages));
                currentStage = "Stage 6";
                processedDataGrabDataModel.TraceData = tempTraceData;
                processedDataGrabDataModel.VehicleData = rawDataGrab.VehicleData;
                processedDataGrabDataModel.BusData = rawDataGrab.BusData;
                processedDataGrabDataModel.mergedFrames = mergedFrames;

                return processedDataGrabDataModel;
            }
            catch (Exception ex)
            {
                throw new Exception(currentStage);
            }
        }
        /// <summary>
        /// To process functional messages
        /// </summary>
        /// <param name="functionalMessages"></param>
        /// <returns></returns>
        private List<TraceDataModel> _processFunctionalMessages(List<string> input)
        {
            var output = new List<TraceDataModel>();
            var requestResponseDataList = new List<string>();
            try
            {
                string functionalMessages = string.Join(Environment.NewLine, input);
                //inputSplitted = functionalMessages.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                //Process block wise
                var functionalAddressList = Constants.FunctionalAddressList.Split('|').ToList();
                var matchString = string.Join("\t|", functionalAddressList);
                var m = Regex.Matches(functionalMessages, matchString, RegexOptions.None);
                if (m == null || m.Count <= 0) return output;
                var i = 0;
                var startIndex = functionalMessages.Substring(0, m[i++].Index).LastIndexOf("\n") + 1;
                var endIndex = functionalMessages.Length - 1;
                while (startIndex < functionalMessages.Length - 1)
                {
                    endIndex = i < m.Count ? (functionalMessages.Substring(0, m[i++].Index).LastIndexOf("\n") + 1) : functionalMessages.Length - 1;
                    var batch = functionalMessages.Substring(startIndex, endIndex - startIndex);
                    var batchDataSplitted = UtilityClass.StringLineSplit(batch);
                    //batchDataSplitted = batch.Split(new[] { Environment.NewLine }, StringSplitOptions.None).ToList();
                    if (batchDataSplitted.Count <= 1)
                    {
                        startIndex = endIndex;
                        continue;
                    }
                    var requestSplitted = batchDataSplitted[0].Split('\t');
                    if (requestSplitted.Length <= 1)
                    {
                        startIndex = endIndex;
                        continue;
                    }
                    var ecuAddress = requestSplitted[0];
                    var ecuExtendedAddress = string.Empty;
                    if (ecuAddress.Contains("-")) ecuExtendedAddress = ecuAddress.Split('-')[1];

                    var request = requestSplitted[1];
                    if (request.Length < 2)
                    {
                        startIndex = endIndex;
                        continue;
                    }

                    var requestSID = request.Substring(0, 2);
                    var requestSIDInt = Convert.ToInt32(requestSID, 16);
                    for (var j = 1; j < batchDataSplitted.Count; j++)
                    {
                        //To remove duplicates
                        var requestResponseData = batchDataSplitted[0] + "~" + batchDataSplitted[j];
                        if (requestResponseDataList.Contains(requestResponseData)) continue;
                        requestResponseDataList.Add(requestResponseData);
                        //
                        var responseSplitted = batchDataSplitted[j].Split('\t');
                        if (responseSplitted.Length <= 1) continue;
                        var responseAddress = responseSplitted[0];
                        var response = responseSplitted[1];

                        //Ignore response pending
                        if (Regex.IsMatch(response, "7F[A-F0-9][A-F0-9]78"))
                            continue;

                        var testerExtendedAddress = string.Empty;
                        if (responseAddress.Contains("-")) testerExtendedAddress = responseAddress.Split('-')[1];

                        //SID check to ensure the proper responses
                        if (response.StartsWith((requestSIDInt + 0x40).ToString("X2")) || response.StartsWith("7F"))
                        {
                            output.Add(
                                new TraceDataModel
                                {
                                    EcuAddress = ecuAddress.Split('-')[0],
                                    TesterAddress = responseAddress.Split('-')[0],
                                    Request = request,
                                    Response = response,
                                    EcuExtendedAddress = ecuExtendedAddress,
                                    TesterExtendedAddress = testerExtendedAddress,
                                }
                            );
                        }
                    }

                    startIndex = endIndex;
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return output;
        }
        /// <summary>
        /// To remove functional messages from trace
        /// </summary>
        /// <param name="trace"></param>
        /// <param name="requestAddresses"></param>
        /// <returns></returns>
        private List<string> _removeFunctionalMessages(List<string> trace, List<string> requestAddresses, out List<string> functionalMessages)
        {
            functionalMessages = new List<string>();
            try
            {
                var tempFunctionalMessages = new StringBuilder();
                var processedTrace = new List<string>();
                //Start Removing functional address
                var functionalAddressList = Constants.FunctionalAddressList.Split('|').ToList();
                functionalAddressList.ForEach(x => requestAddresses.Remove(x));
                var regEx = new Regex(string.Join("\t|", requestAddresses) + "\t", RegexOptions.Compiled);
                var funRegEx = new Regex(string.Join("\t|", functionalAddressList) + "\t", RegexOptions.Compiled);
                for (var i = 0; i < trace.Count; i++)
                {
                    if (funRegEx.IsMatch(trace[i]))
                    {
                        functionalMessages.Add(trace[i]);
                        var j = i + 1;
                        while (j < trace.Count)
                        {
                            if (regEx.IsMatch(trace[j]))
                                break;
                            functionalMessages.Add(trace[j]);
                            j++;
                        }
                        i = j;
                    }
                    if (i < trace.Count)
                        processedTrace.Add(trace[i]);
                }
                //End removing functional address
                return processedTrace;
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }
        /// <summary>
        /// Get request response message pairs
        /// </summary>
        /// <param name="input"></param>
        /// <param name="requestAddress"></param>
        /// <param name="responseAddress"></param>
        /// <returns></returns>
        private Dictionary<string, List<string>> _getRequestResponsePairs(List<string> input, string requestAddress, string responseAddress)
        {
            var requestResponses = new Dictionary<string, List<string>>();
            try
            {
                //inputSplitted = input.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                var functionalAddressList = Constants.FunctionalAddressList.Split('|').ToList();
                for (var i = 0; i < input.Count; i++)
                {
                    if (!input[i].StartsWith(requestAddress + '\t')) continue;
                    var request = input[i].Split('\t')[1];
                    var response = string.Empty;
                    //Now find the responses
                    for (var j = i + 1; j < input.Count; j++)
                    {
                        if (input[j].StartsWith(requestAddress + '\t')) break;
                        if (functionalAddressList.Where(x => input[j].Contains(x + "\t")).Count() > 0)
                            break;
                        response += input[j].Split('\t')[1] + "~";
                    }
                    response = response.Trim('~');
                    //Bring multiple response
                    if (!requestResponses.ContainsKey(request)) requestResponses.Add(request, new List<string>());
                    if (!requestResponses[request].Contains(response)) requestResponses[request].Add(response);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return requestResponses;
        }

        /// <summary>
        /// To find request response address pairs
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private Dictionary<string, string> _findRequestResponseAddressPairs(List<string> input, List<string> rawTraceSplitted)
        {
            var requestResponseAddressPairs = new Dictionary<string, string>();
            try
            {
                var possibleResponseAddress = _getValidResponseAddresses(input);

                var validResponseAddressWithoutRequestAddress = new Dictionary<string, List<string>>();
                var validAddressCount = 0;
                do
                {
                    validResponseAddressWithoutRequestAddress.Clear();
                    validAddressCount = requestResponseAddressPairs.Count();
                    //Find the corresponding request IDs
                    foreach (var responseAddress in possibleResponseAddress)
                    {
                        if (requestResponseAddressPairs.ContainsValue(responseAddress)) continue;
                        //Now get the ECU address
                        var requestAddress = _getRequestAddress(input, responseAddress, out List<string> requestAddressPossibilities);
                        if (string.IsNullOrEmpty(requestAddress) && requestAddressPossibilities.Count > 0)
                        {
                            validResponseAddressWithoutRequestAddress.Add(responseAddress, requestAddressPossibilities);
                            continue;
                        }
                        else if (!string.IsNullOrEmpty(requestAddress))
                        {
                            if (!requestResponseAddressPairs.ContainsKey(requestAddress))
                                requestResponseAddressPairs.Add(requestAddress, responseAddress);
                        }
                        var regex = new Regex("^(" + responseAddress + "\t|" + requestAddress + "\t)", RegexOptions.Compiled);
                        input = _filterTrace(input, new List<string> { responseAddress, requestAddress }, false);
                    }
                } while (validAddressCount < requestResponseAddressPairs.Count);

                if (validResponseAddressWithoutRequestAddress.Count > 0)
                {
                    var tryForRequsetAddress = validResponseAddressWithoutRequestAddress.ToDictionary(x => x.Key, y => y.Value);
                    var foundAddresses = new List<string>();
                    foundAddresses.AddRange(requestResponseAddressPairs.Keys);
                    foundAddresses.AddRange(requestResponseAddressPairs.Values);
                    var rawTrace = _getValidDiagnosticFrames(rawTraceSplitted, foundAddresses, false);
                    rawTraceSplitted = UtilityClass.StringLineSplit(rawTrace);

                    //If there are missing addresses then try to see whether we can find the request address using flow control parameter
                    foreach (var addressPairs in tryForRequsetAddress)
                    {
                        var multiFrameResPattern = addressPairs.Key.Replace("-", "[ ]+") + "[ ]+1[A-F0-9] .*" + Environment.NewLine;
                        var multiFrameResponses = Regex.Matches(rawTrace, multiFrameResPattern, RegexOptions.Multiline);
                        //If no multi frame response available then nothing can be done
                        if (multiFrameResponses.Count <= 0) continue;
                        foreach (var possibleRequestAddress in addressPairs.Value)
                        {
                            if (requestResponseAddressPairs.Keys.Contains(possibleRequestAddress)) continue;

                            var addresesToFilter = new List<string> { addressPairs.Key, possibleRequestAddress };
                            var filterdTraces = _getValidDiagnosticFrames(rawTraceSplitted, addresesToFilter);
                            var pattern = multiFrameResPattern + "^.*" + possibleRequestAddress.Replace("-", "[ ]+") + "[ ]+30 .*" + Environment.NewLine;
                            var matches = Regex.Matches(filterdTraces, pattern, RegexOptions.Multiline);
                            //if proper 30 request from request address for all multi frame response then it is a valid response address
                            if (multiFrameResponses.Count != matches.Count) continue;
                            requestResponseAddressPairs.Add(possibleRequestAddress, addressPairs.Key);
                            validResponseAddressWithoutRequestAddress.Remove(addressPairs.Key);
                            break;
                        }
                    }
                    #region CANFD_SUPPORT
                    var addressFormatTry = validResponseAddressWithoutRequestAddress.ToList();
                    //try 18DAxxyy format
                    foreach (var addressPairs in addressFormatTry)
                    {
                        var responseAddress = addressPairs.Key;
                        if (responseAddress.Length != 8) continue;
                        var firstByte = responseAddress.Substring(0, 2);
                        var lastBytes = new StringBuilder(responseAddress.Substring(6, 2))
                                                    .Append(responseAddress.Substring(4, 2)).ToString();
                        //182AF123 can request address 18DA23F1, so ignore the second byte
                        foreach (var reqAdd in addressPairs.Value)
                        {
                            if (!reqAdd.StartsWith(firstByte) || !reqAdd.EndsWith(lastBytes)) continue;
                            requestResponseAddressPairs.Add(reqAdd, responseAddress);
                            break;
                        }
                        validResponseAddressWithoutRequestAddress.Remove(responseAddress);
                    }
                    #endregion

                    //if (validResponseAddressWithoutRequestAddress.Count > 0)
                    //    throw new Exception("Not able to find request address for all response addresses");
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return requestResponseAddressPairs;
        }
        /// <summary>
        /// Get request address corresponding to the given response address
        /// </summary>
        /// <param name="tempinput"></param>
        /// <param name="responseAddress"></param>
        /// <returns></returns>
        private string _getRequestAddress(List<string> input, string responseAddress, out List<string> requestAddressPossibilities)
        {
            var regEx = new Regex("^.*(\t7F[A-F0-9][A-F0-9]78).*$", RegexOptions.Compiled);
            requestAddressPossibilities = new List<string>();
            var requestAddressPossibilitiesCount = 0;
            try
            {
                //Ignore response pending
                var inputSplitted = input.Where(x => !regEx.IsMatch(x)).ToList();

                //inputSplitted = tempinput.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                var functionalAddressList = Constants.FunctionalAddressList.Split('|').ToList();
                for (var i = inputSplitted.Count - 1; i >= 0; i--)
                {
                    if (!inputSplitted[i].StartsWith(responseAddress)) continue;
                    var tempResponseSplitted = inputSplitted[i].Split('\t');
                    if (tempResponseSplitted.Count() != 2) return string.Empty;
                    var response = tempResponseSplitted[1];
                    var responseSid = response.Substring(0, 2);
                    var requestSid = string.Empty;

                    if (responseSid.Equals("7F") && response.Length >= 4)
                    {
                        if (response.Length < 4)
                            continue;

                        requestSid = response.Substring(2, 2);
                    }
                    else
                        requestSid = (Convert.ToInt32(responseSid, 16) - 0x40).ToString("X2");

                    //Check whether the request SID is available or not
                    var searchRange = string.Join(Environment.NewLine, inputSplitted.GetRange(0, i).ToList());
                    if (searchRange.Contains(responseAddress + "\t"))
                    {
                        var addressMatches = Regex.Matches(searchRange, responseAddress + "\t");
                        var data = searchRange.Substring(addressMatches[addressMatches.Count - 1].Index);
                        for (var j = addressMatches.Count - 2; j >= 0; j--)
                        {
                            //Need to handle multiple response here
                            if (data.Contains(Environment.NewLine)) break;
                            data = searchRange.Substring(addressMatches[j].Index, addressMatches[j + 1].Index - addressMatches[j].Index);
                        }
                        searchRange = data;
                    }
                    MatchCollection isRequestSIDAvailable = null;
                    var requestPattern = string.Empty;
                    do
                    {
                        if (response.StartsWith("7F") || response.Length <= 2)
                            requestPattern = requestSid;
                        else if (string.IsNullOrEmpty(requestPattern))
                            requestPattern = requestSid + response.Substring(2, response.Length - 2 > 4 ? 4 : response.Length - 2);
                        else
                            requestPattern = requestPattern.Substring(0, requestPattern.Length - 2);

                        //Special case for SID 19
                        if (requestSid == "19")
                            requestPattern = requestPattern.Length > 4 ? requestPattern.Substring(0, 4) : requestPattern;

                        var pattern = Regex.Replace(responseAddress, "[A-F0-9]", "[A-F0-9]");
                        //Keep the extended address
                        if (responseAddress.Contains('-'))
                        {
                            //Handling MB type extended addresses
                            var mainAddress = responseAddress.Split('-')[0];
                            var extendedPattern = Regex.Replace(mainAddress, "[A-F0-9]", "[A-F0-9]") + "-" + responseAddress.Split('-')[1];
                            isRequestSIDAvailable = Regex.Matches(searchRange, extendedPattern + "\t" + requestPattern + ".*$", RegexOptions.Multiline);
                            if (isRequestSIDAvailable == null || isRequestSIDAvailable.Count <= 0)
                            {
                                //Handle BMW type extended address
                                mainAddress = responseAddress.Split('-')[0];
                                var extendedAddress = responseAddress.Split('-')[1];
                                var bmwTypePattern = Regex.Replace(mainAddress.Substring(0, mainAddress.Length - 2), "[A-F0-9]", "[A-F0-9]");
                                bmwTypePattern = bmwTypePattern + extendedAddress + "-" + mainAddress.Substring(mainAddress.Length - 2);
                                //extendedPattern = Regex.Replace(mainAddress, "[A-F0-9]", "[A-F0-9]") + "-" + responseAddress.Split('-')[1];
                                isRequestSIDAvailable = Regex.Matches(searchRange, bmwTypePattern + "\t" + requestPattern + ".*$", RegexOptions.Multiline);
                            }
                        }
                        if (isRequestSIDAvailable == null || isRequestSIDAvailable.Count <= 0)
                            isRequestSIDAvailable = Regex.Matches(searchRange, "^" + pattern + "\t" + requestPattern + ".*$", RegexOptions.Multiline);

                        //If the data found then break
                        if (isRequestSIDAvailable != null && isRequestSIDAvailable.Count > 0)
                            break;
                    } while (!string.IsNullOrEmpty(requestPattern) && requestPattern.Length > 2);

                    var matchingSids = new List<string>();
                    for (int matchIdx = isRequestSIDAvailable.Count - 1; matchIdx >= 0; matchIdx--)
                    {
                        //If there is a request with functional address then it may be possible that this response belongs to that request
                        //Should ignore such cases and try for a different match
                        if (functionalAddressList.Where(x => isRequestSIDAvailable[matchIdx].ToString().Contains(x)).Count() > 0) break;
                        matchingSids.Add(isRequestSIDAvailable[matchIdx].ToString());
                    }
                    if (isRequestSIDAvailable.Count <= 0 && requestAddressPossibilitiesCount <= 0)
                        return string.Empty;
                    //If only functional address then try the next one
                    if (matchingSids.Count <= 0) continue;

                    //If a single match found then that should be the request address
                    if (matchingSids.Count == 1)
                    {
                        return matchingSids[0].ToString().Split('\t')[0];
                    }
                    if (requestAddressPossibilitiesCount <= 0)
                    {
                        foreach (var match in matchingSids)
                        {
                            requestAddressPossibilities.Add(match.Split('\t')[0]);
                        }
                        requestAddressPossibilitiesCount = requestAddressPossibilities.Count;
                    }
                    else
                    {
                        var tempData = new List<string>();
                        foreach (var match in matchingSids)
                        {
                            tempData.Add(match.Split('\t')[0]);
                        }
                        requestAddressPossibilities = requestAddressPossibilities.Intersect(tempData).ToList();
                        requestAddressPossibilitiesCount = requestAddressPossibilities.Count;
                    }
                }
                if (requestAddressPossibilities.Count == 1)
                    return requestAddressPossibilities[0];
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return string.Empty;
        }
        /// <summary>
        /// Find SID of the request from response frame
        /// </summary>
        /// <param name="response"></param>
        /// <returns></returns>
        private string _getRequestSid(string response)
        {
            try
            {
                if (string.IsNullOrEmpty(response)) return string.Empty;
                var firstbyte = response.Substring(0, 2);
                var sid = Convert.ToInt32(firstbyte, 16) - 0x40;
                if (sid < 0) return string.Empty;
                if (firstbyte == "7F")
                {
                    if (response.Length <= 4) return "7F";
                    sid = Convert.ToInt32(response.Substring(2, 2), 16);
                }
                return sid.ToString("X2");
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return string.Empty;
        }
        /// <summary>
        /// To find valid responses addresses
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private List<string> _getValidResponseAddresses(List<string> input)
        {
            var possibleResponseAddress = new List<string>();
            var clubbedMessages = _clubMessages(input);
            var orderdMessages = clubbedMessages.OrderBy(x => x.Value.Count).Reverse().ToDictionary(x => x.Key, x => x.Value);
            //Now need to find the request and response address pairs
            foreach (var address in orderdMessages.Keys)
            {
                //Try to identify a request address for the response
                var messages = orderdMessages[address];
                var isResponseAddress = true;
                foreach (var message in messages)
                {
                    if (!string.IsNullOrEmpty(_getRequestSid(message))) continue;
                    isResponseAddress = false;
                    break;
                }
                if (isResponseAddress) possibleResponseAddress.Add(address);
            }
            return possibleResponseAddress;
        }
        /// <summary>
        /// Club can frames based on the address
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private Dictionary<string, List<string>> _clubMessages(List<string> inputSplitted)
        {
            var canAddresses = new Dictionary<string, List<string>>();
            try
            {
                //inputSplitted = input.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                foreach (var canFrame in inputSplitted)
                {
                    var frameSplitted = canFrame.Split('\t');
                    if (frameSplitted.Count() != 2) continue;
                    if (!canAddresses.ContainsKey(frameSplitted[0])) canAddresses.Add(frameSplitted[0], new List<string>());
                    canAddresses[frameSplitted[0]].Add(frameSplitted[1]);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return canAddresses;
        }
        /// <summary>
        /// Merge can frames
        /// </summary>
        /// <param name="input"></param>
        /// <param name="ValidCanIdsWithExt"></param>
        /// <returns></returns>
        private List<string> _mergeCanFrames(List<string> input, List<string> ValidCanIds, List<string> ValidCanIdsWithExt)
        {
            var output = new List<string>();
            var indexesToIgnore = new List<int>();
            var i = 0;
            try
            {
                //inputSplitted = input.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                while (i < input.Count())
                {
                    if (indexesToIgnore.Contains(i))
                    {
                        i++;
                        continue;
                    }
                    var address = _getAddress(input[i], out string payload);
                    if (string.IsNullOrEmpty(address) || string.IsNullOrEmpty(payload))
                    {
                        i++;
                        continue;
                    }
                    var firstByte = payload.Substring(0, 2);
                    var canMessage = payload.Substring(2);
                    var isExtendedAddress = false;
                    //Check for extended address, if extended address then ignore the first byte
                    if (ValidCanIdsWithExt.Contains(new StringBuilder(address).Append("-").Append(firstByte).ToString()))
                    {
                        address = address + "-" + firstByte;
                        firstByte = canMessage.Substring(0, 2);
                        payload = payload.Substring(2);
                        canMessage = payload.Substring(2);
                        isExtendedAddress = true;
                    }
                    else if (!ValidCanIds.Contains(address))
                    {
                        i++;
                        continue;
                    }
                    #region CANFD_SUPPORT
                    if (firstByte == "00")
                    {
                        var tempFirstByte = canMessage.Substring(0, 2);
                        var tempByteInt = Convert.ToInt32(tempFirstByte, 16);
                        if (tempByteInt < 8 || tempByteInt > 62 || (canMessage.Length / 2) <= tempByteInt)
                        {
                            i++;
                            continue;
                        }
                        firstByte = tempFirstByte;
                        canMessage = canMessage.Substring(2);
                    }
                    #endregion
                    //Ignore partial flow control frames
                    if (payload.StartsWith("3") || payload.StartsWith("2") || canMessage.StartsWith("00"))
                    {
                        i++;
                        continue;
                    }

                    var messageLenth = Convert.ToInt32(firstByte, 16);
                    //Check for multi frame messages
                    if (payload.StartsWith("1"))
                    {
                        canMessage = canMessage.Substring(2);
                        messageLenth = Convert.ToInt32(payload.Substring(1, 3), 16);
                        var j = i + 1;
                        i++;
                        var appendedMessageLength = canMessage.Length / 2;
                        var flowControl = -1;
                        for (; j < input.Count; j++)
                        {
                            var tempAddress = _getAddress(input[j], out string tempMessage);
                            if (isExtendedAddress)
                            {
                                tempAddress += "-" + tempMessage.Substring(0, 2);
                                tempMessage = tempMessage.Substring(2).Trim();
                            }
                            if (!tempAddress.Equals(address)) continue;
                            //Get first flow control data
                            if (flowControl == -1)
                            {
                                var flowControlByte = tempMessage.Substring(1, 1);
                                flowControl = Convert.ToInt32(flowControlByte, 16);
                            }
                            if (!tempMessage.StartsWith("2" + flowControl.ToString("X"))) break;

                            var tempFrame = tempMessage.Substring(2);
                            indexesToIgnore.Add(j);
                            appendedMessageLength += tempFrame.Length / 2;
                            canMessage += tempFrame;
                            if (appendedMessageLength >= messageLenth) break;
                            flowControl++;
                            if (flowControl == 16) flowControl = 0;
                        }
                    }
                    else
                    {
                        if (indexesToIgnore.Count > 0 && indexesToIgnore.Max() < i)
                            indexesToIgnore.Clear();
                        i++;
                    }
                    //Check whether complete message available or not
                    if (canMessage.Length >= messageLenth * 2)
                    {
                        var validMessage = canMessage.Substring(0, messageLenth * 2);
                        output.Add(new StringBuilder(address).Append("\t")
                                    .Append(validMessage)
                                    .ToString());
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return output;
        }
        /// <summary>
        /// To check whether the given list of can messages are valid diagnostic frames or not. The full list must be of the same can ID
        /// </summary>
        /// <param name="canMessages"></param>
        /// <returns></returns>
        public bool _isvalidDiagnosticFrames(List<string> canMessages)
        {
            int validFrames = 0;
            try
            {
                for (var i = 0; i < canMessages.Count; i++)
                {
                    if (Regex.IsMatch(canMessages[i], "[^A-F0-9]")) continue;

                    var payload = canMessages[i];
                    var frameByteLength = payload.Length / 2;
                    //Some concession for the last frame
                    if (payload.Length < 4 && i < canMessages.Count - 1)
                        return false;
                    var messageLength = payload.Substring(0, 2);
                    var lengthInt = Convert.ToInt32(messageLength, 16);
                    var dataByteLenInFrame = 7;
                    #region CANFD_SUPPORT
                    if (lengthInt == 0 && payload.Length > 4)
                    {
                        var tempMessageLength = payload.Substring(1, 3);
                        var tempLengthInt = Convert.ToInt32(tempMessageLength, 16);
                        //for CAN FD the first byte will be 00 only if the length is greater than 8 and less than 63
                        if (tempLengthInt < 8 || tempLengthInt > 62) return false;
                        messageLength = tempMessageLength;
                        lengthInt = tempLengthInt;
                    }
                    if ((payload.Length / 2) > 8) dataByteLenInFrame = 63;
                    #endregion

                    if (lengthInt < 1)
                        return false;
                    //Ignore flow control message
                    if (payload.StartsWith("30"))
                    {
                        validFrames++;
                        continue;
                    }

                    var messageData = payload.Substring(2);

                    messageData = messageData.Trim();
                    if (string.IsNullOrEmpty(messageData))
                        return false;
                    frameByteLength--;
                    //If message start with 2 then it is a reminder of old multi frame
                    //If message start with 3 then it is flow control message
                    //Ignore both
                    if (messageLength.StartsWith("2") || messageLength.StartsWith("3")) continue;
                    //If multi frame then first byte will start with 1
                    if (messageLength.StartsWith("1"))
                    {
                        if (payload.Length < (dataByteLenInFrame - 1) && i < canMessages.Count - 1)
                            return false;
                        messageLength = payload.Substring(1, 3);
                        lengthInt = Convert.ToInt32(messageLength, 16);
                        var j = i + 1;
                        var byteLength = payload.Substring(4).Length / 2;
                        //If multi frame then check for flow control
                        for (; j < canMessages.Count; j++)
                        {
                            if (!canMessages[j].StartsWith("2")) break; ;
                            var flowControlNibble = canMessages[j].Substring(1, 1);
                            var fcInt = Convert.ToInt32(flowControlNibble, 16);
                            if (!(fcInt == ((j - i) & 0xF) || fcInt == ((j - i) & 0xF) - 1)) break;
                            byteLength += (canMessages[j].Length / 2) - 1;
                        }
                        if ((byteLength - lengthInt) < dataByteLenInFrame && j > i + 1)
                        {
                            validFrames += (j - i);
                        }
                        else
                        {

                        }
                        i = j - 1;
                    }
                    else
                    {
                        if (lengthInt > frameByteLength)
                            return false;
                        //Anoopchandra: It is not guarenteed that the filler bytes will be same bytes repeating over and over again
                        //Now need to check the filler bytes
                        //var additionalBytes = payload.Substring(2).Substring(lengthInt * 2);
                        //if (!string.IsNullOrEmpty(additionalBytes) && !string.IsNullOrEmpty(additionalBytes.Replace(additionalBytes.Substring(0, 1), "").Trim()))
                        //    return false;
                        validFrames++;
                    }
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return validFrames <= 0 ? false : validFrames > canMessages.Count * 0.8;
        }
        /// <summary>
        /// Get valid diagnostic frames matching with the given addresses
        /// </summary>
        /// <param name="input"></param>
        /// <param name="validCanAddresses"></param>
        /// <returns></returns>
        private string _getValidDiagnosticFrames(List<string> inputSplitted, List<string> validCanAddresses
            , bool isPassFilter = true)
        {
            try
            {
                var validFrames = new StringBuilder();
                var regEx = new Regex(("[ ]+" + string.Join("|[ ]+", validCanAddresses))
                                    .Replace("-", "[ ]+"), RegexOptions.Compiled);
                foreach (var frame in inputSplitted)
                {
                    if (isPassFilter && regEx.IsMatch(frame))
                        validFrames.Append(frame.Trim()).Append(Environment.NewLine);
                    else if (!isPassFilter && !regEx.IsMatch(frame))
                        validFrames.Append(frame.Trim()).Append(Environment.NewLine);
                }
                return validFrames.ToString().Trim();
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return string.Empty;
        }
        private List<string> _getValidDiagnosticFramesAsList(List<string> inputSplitted, List<string> validCanAddresses
                        , bool isPassFilter = true)
        {
            var validFrames = new List<string>();
            try
            {
                var regEx = new Regex(("[ ]+" + string.Join("|[ ]+", validCanAddresses))
                                    .Replace("-", "[ ]+"), RegexOptions.Compiled);
                foreach (var frame in inputSplitted)
                {
                    if (isPassFilter && regEx.IsMatch(frame))
                        validFrames.Add(frame.Trim());
                    else if (!isPassFilter && !regEx.IsMatch(frame))
                        validFrames.Add(frame.Trim());
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return validFrames;
        }
        /// <summary>
        /// Filter trace based on the given can addresses
        /// </summary>
        /// <param name="input"></param>
        /// <param name="canAddresses"></param>
        /// <returns></returns>
        private List<string> _filterTrace(List<string> input, List<string> canAddresses, bool isPassFilter = true)
        {
            try
            {
                var validFrames = new List<string>();
                //inputSplitted = input.Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries).ToList();
                foreach (var canFrame in input)
                {
                    var address = canFrame.Split('\t')[0];
                    if (string.IsNullOrEmpty(address)) continue;
                    if (isPassFilter)
                    {
                        if (canAddresses.Contains(address)) validFrames.Add(canFrame);
                    }
                    else if (!canAddresses.Contains(address)) validFrames.Add(canFrame);
                }
                return validFrames;
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return new List<string>();
        }

        /// <summary>
        /// To get address from can frame
        /// </summary>
        /// <param name="canFrame"></param>
        /// <param name="payload"></param>
        /// <returns></returns>
        private string _getAddress(string canFrame, out string payload)
        {
            payload = string.Empty;
            try
            {
                //Handling 11bit address
                var match = Regex.Match(canFrame, " [A-F0-9]{3} ");
                if (!match.Success)
                {
                    //Handling 29bit address
                    match = Regex.Match(canFrame, " [A-F0-9]{8} ");
                }
                if (!match.Success) return string.Empty;
                payload = canFrame.Substring(canFrame.IndexOf(match.Value.Trim())).Replace(match.Value.Trim(), string.Empty).Trim();
                payload = payload.Replace(" ", string.Empty);
                return match.Value.Trim();
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return string.Empty;
        }
        /// <summary>
        /// Get all can addresses in the given trace
        /// </summary>
        /// <param name="input"></param>
        /// <returns></returns>
        private Dictionary<string, List<string>> _getCanAddresses(List<string> input)
        {
            var canAddresses = new Dictionary<string, List<string>>();
            try
            {
                foreach (var line in input)
                {
                    var ecuAddress = _getAddress(line, out string payload);
                    if (string.IsNullOrEmpty(ecuAddress)) continue;
                    if (!canAddresses.ContainsKey(ecuAddress)) canAddresses.Add(ecuAddress, new List<string>());
                    canAddresses[ecuAddress].Add(payload);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return canAddresses;
        }
        /// <summary>
        /// Get Extended address from the given trace for the given can addresses
        /// </summary>
        /// <param name="canAddresses"></param>
        /// <returns></returns>
        private Dictionary<string, Dictionary<string, List<string>>> _getCanExtAddress(Dictionary<string, List<string>> canAddresses)
        {
            var canExtAddresses = new Dictionary<string, Dictionary<string, List<string>>>();
            try
            {
                foreach (var canData in canAddresses)
                {
                    var address = canData.Key;
                    var canFrameData = canData.Value;
                    var extendedAddressData = new Dictionary<string, List<string>>();
                    foreach (var canFrame in canFrameData)
                    {
                        var tempFrame = canFrame;
                        //There should be atleast 3 bytes then only the frame can be considered value
                        if (tempFrame.Length < 6) continue;
                        var extAddress = tempFrame.Substring(0, 2);

                        if (!extendedAddressData.ContainsKey(extAddress))
                            extendedAddressData.Add(extAddress, new List<string>());

                        extendedAddressData[extAddress].Add(canFrame.Substring(2).Trim());
                    }
                    canExtAddresses.Add(address, extendedAddressData);
                }
            }
            catch (Exception ex)
            {
                throw ex;
            }
            return canExtAddresses;
        }
    }//end SamdiaPreProcessor

}//end namespace DataGrabPreProcessor